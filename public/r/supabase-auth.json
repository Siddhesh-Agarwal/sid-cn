{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "supabase-auth",
  "type": "registry:component",
  "title": "Supabase Auth",
  "description": "A complete working supabase auth setup",
  "dependencies": [
    "@supabase/ssr",
    "@supabase/supabase-js",
    "lucide-react"
  ],
  "registryDependencies": [
    "https://ui.siddhesh.cc/r/button.json",
    "dialog",
    "dropdown-menu",
    "form",
    "input",
    "tabs"
  ],
  "files": [
    {
      "path": "registry/new-york/supabase/components/auth.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogHeader,\r\n  DialogTitle,\r\n  DialogTrigger,\r\n} from \"@/components/ui/dialog\";\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\r\nimport { SignInForm } from \"@/registry/new-york/supabase/components/sign-in-form\";\r\nimport { SignUpForm } from \"@/registry/new-york/supabase/components/sign-up-form\";\r\nimport { useAuth } from \"@/registry/new-york/supabase/lib/auth\";\r\n\r\nimport React from \"react\";\r\nimport Link from \"next/link\";\r\nimport { LogOut } from \"lucide-react\";\r\n\r\nexport function SignedIn({ children }: { children: React.ReactNode }) {\r\n  const { user, loading } = useAuth();\r\n\r\n  if (loading) return null; // or a loading spinner if you prefer\r\n  if (!user) return null;\r\n\r\n  return <>{children}</>;\r\n}\r\n\r\nexport function SignedOut({ children }: { children: React.ReactNode }) {\r\n  const { user, loading } = useAuth();\r\n\r\n  if (loading) return null; // or a loading spinner if you prefer\r\n  if (user) return null;\r\n\r\n  return <>{children}</>;\r\n}\r\n\r\nexport function AuthButton({\r\n  redirectOnLogin = \"/\",\r\n  children,\r\n}: {\r\n  redirectOnLogin?: string;\r\n  children: React.ReactNode;\r\n}) {\r\n  return (\r\n    <Dialog>\r\n      <DialogTrigger asChild>{children}</DialogTrigger>\r\n      <DialogContent>\r\n        <DialogHeader>\r\n          <DialogTitle>Authentication</DialogTitle>\r\n          <DialogDescription>\r\n            Create account or log into an existing account.\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n        <Tabs className=\"w-full\">\r\n          <TabsList className=\"w-full mb-4\">\r\n            <TabsTrigger value=\"sign-in\">Sign In</TabsTrigger>\r\n            <TabsTrigger value=\"sign-up\">Sign Up</TabsTrigger>\r\n          </TabsList>\r\n          <TabsContent value=\"sign-in\">\r\n            <SignInForm redirect={redirectOnLogin} />\r\n          </TabsContent>\r\n          <TabsContent value=\"sign-up\">\r\n            <SignUpForm />\r\n          </TabsContent>\r\n        </Tabs>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n\r\ntype AuthVariant = \"modal\" | \"page\";\r\n\r\nexport function SignInButton({\r\n  variant = \"modal\",\r\n  redirect = \"/\",\r\n  children,\r\n}: {\r\n  variant?: AuthVariant;\r\n  redirect?: string;\r\n  children: React.ReactNode;\r\n}) {\r\n  if (variant === \"page\") {\r\n    const params = new URLSearchParams({ redirect });\r\n    return <Link href={`/auth/sign-in?${params}`}>{children}</Link>;\r\n  }\r\n  return (\r\n    <Dialog>\r\n      <DialogTrigger asChild>{children}</DialogTrigger>\r\n      <DialogContent>\r\n        <DialogHeader>\r\n          <DialogTitle>Sign In</DialogTitle>\r\n          <DialogDescription>Log in to your account.</DialogDescription>\r\n        </DialogHeader>\r\n        <SignInForm redirect={redirect} />\r\n        <div className=\"w-full flex justify-center\">\r\n          Don't have an account?\r\n          <Link href=\"/auth/sign-up\" className=\"ml-1 hover:underline\">\r\n            Sign up\r\n          </Link>\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n\r\nexport function SignUpButton({\r\n  variant = \"modal\",\r\n  children,\r\n}: {\r\n  variant?: AuthVariant;\r\n  children: React.ReactNode;\r\n}) {\r\n  if (variant === \"page\") {\r\n    return <Link href=\"/auth/sign-up\">{children}</Link>;\r\n  }\r\n  return (\r\n    <Dialog>\r\n      <DialogTrigger asChild>{children}</DialogTrigger>\r\n      <DialogContent>\r\n        <DialogHeader>\r\n          <DialogTitle>Sign Up</DialogTitle>\r\n          <DialogDescription>Create a new account.</DialogDescription>\r\n        </DialogHeader>\r\n        <SignUpForm />\r\n        <div className=\"w-full flex justify-center\">\r\n          Already have an account?\r\n          <Link href=\"/auth/sign-in\" className=\"ml-1 hover:underline\">\r\n            Sign in\r\n          </Link>\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n\r\nexport function UserButton({ children }: { children: React.ReactNode }) {\r\n  const { user, loading } = useAuth();\r\n\r\n  if (loading) return null;\r\n\r\n  return (\r\n    <DropdownMenu>\r\n      <DropdownMenuTrigger asChild>{children}</DropdownMenuTrigger>\r\n      <DropdownMenuContent>\r\n        <DropdownMenuItem>Profile</DropdownMenuItem>\r\n        <DropdownMenuItem onClick={() => user}>\r\n          <LogOut />\r\n          Log out\r\n        </DropdownMenuItem>\r\n      </DropdownMenuContent>\r\n    </DropdownMenu>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/supabase/components/sign-in-form.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Form,\r\n  FormControl,\r\n  FormField,\r\n  FormItem,\r\n  FormLabel,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\n\r\nimport { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport { LogIn } from \"lucide-react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { toast } from \"sonner\";\r\nimport z from \"zod\";\r\n\r\nexport const signInSchema = z.object({\r\n  email: z.email(),\r\n  password: z.string().min(8),\r\n});\r\n\r\nexport type SignInSchema = z.infer<typeof signInSchema>;\r\n\r\nexport function SignInForm({ redirect }: { redirect: string }) {\r\n  const form = useForm<SignInSchema>({\r\n    resolver: zodResolver(signInSchema),\r\n  });\r\n  const router = useRouter();\r\n\r\n  function onSubmit(data: SignInSchema) {\r\n    fetch(\"/api/auth/sign-in\", {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(data),\r\n    })\r\n      .then((response) => {\r\n        if (!response.ok) throw new Error(response.statusText);\r\n        router.push(redirect);\r\n      })\r\n      .catch((error) => {\r\n        toast.error(\"Error signing in\", { description: error.message });\r\n      });\r\n  }\r\n  return (\r\n    <Form {...form}>\r\n      <form\r\n        onSubmit={form.handleSubmit(onSubmit)}\r\n        className=\"flex flex-col gap-4\"\r\n      >\r\n        <FormField\r\n          control={form.control}\r\n          name=\"email\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Email</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"email\" autoFocus />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <FormField\r\n          control={form.control}\r\n          name=\"password\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Password</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"password\" />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <Button variant={\"default\"} type=\"submit\" className=\"w-full mt-4\">\r\n          Sign in\r\n          <LogIn />\r\n        </Button>\r\n      </form>\r\n    </Form>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/supabase/components/sign-up-form.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Form,\r\n  FormControl,\r\n  FormField,\r\n  FormItem,\r\n  FormLabel,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\n\r\nimport { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport { LogIn } from \"lucide-react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { toast } from \"sonner\";\r\nimport z from \"zod\";\r\n\r\nexport const signUpSchema = z.object({\r\n  firstName: z.string().min(1),\r\n  lastName: z.string().min(1),\r\n  email: z.email(),\r\n  password: z.string().min(1),\r\n  confirmPassword: z.string().min(1),\r\n});\r\n\r\nexport type SignUpSchema = z.infer<typeof signUpSchema>;\r\n\r\nexport function SignUpForm() {\r\n  const form = useForm<SignUpSchema>({\r\n    resolver: zodResolver(signUpSchema),\r\n  });\r\n  const router = useRouter();\r\n\r\n  function onSubmit(data: SignUpSchema) {\r\n    fetch(\"/api/auth/sign-up\", {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(data),\r\n    })\r\n      .then((response) => {\r\n        if (!response.ok) throw new Error(response.statusText);\r\n        router.push(\"/auth/sign-in\");\r\n      })\r\n      .catch((error) => {\r\n        toast.error(\"Error signing up\", { description: error.message });\r\n      });\r\n  }\r\n\r\n  return (\r\n    <Form {...form}>\r\n      <form\r\n        onSubmit={form.handleSubmit(onSubmit)}\r\n        className=\"flex flex-col gap-4\"\r\n      >\r\n        <FormField\r\n          control={form.control}\r\n          name=\"firstName\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>First Name</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"text\" autoFocus />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <FormField\r\n          control={form.control}\r\n          name=\"lastName\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Last Name</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"text\" />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <FormField\r\n          control={form.control}\r\n          name=\"email\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Email</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"email\" />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <FormField\r\n          control={form.control}\r\n          name=\"password\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Password</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"password\" />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <FormField\r\n          control={form.control}\r\n          name=\"confirmPassword\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Confirm Password</FormLabel>\r\n              <FormControl>\r\n                <Input {...field} type=\"password\" />\r\n              </FormControl>\r\n            </FormItem>\r\n          )}\r\n        />\r\n        <Button variant={\"default\"} type=\"submit\" className=\"w-full mt-4\">\r\n          Sign up\r\n          <LogIn />\r\n        </Button>\r\n      </form>\r\n    </Form>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/supabase/lib/auth.ts",
      "content": "import { useEffect, useState } from \"react\";\r\nimport { createClient } from \"@/registry/new-york/supabase/lib/client\";\r\n\r\nexport type Session = NonNullable<\r\n  Awaited<\r\n    ReturnType<\r\n      NonNullable<ReturnType<typeof createClient>>[\"auth\"][\"getSession\"]\r\n    >\r\n  >[\"data\"][\"session\"]\r\n>;\r\n\r\nexport type User = Session[\"user\"];\r\n\r\nexport function useAuth() {\r\n  const [user, setUser] = useState<User | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const supabase = createClient();\r\n\r\n  useEffect(() => {\r\n    if (!supabase) {\r\n      setLoading(false);\r\n      return;\r\n    }\r\n\r\n    // Get initial session\r\n    const getSession = async () => {\r\n      try {\r\n        const {\r\n          data: { session },\r\n        } = await supabase.auth.getSession();\r\n        setUser(session?.user ?? null);\r\n      } catch (e) {\r\n        console.error(e);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    getSession();\r\n\r\n    // Listen for auth changes\r\n    const {\r\n      data: { subscription },\r\n    } = supabase.auth.onAuthStateChange((_, session) => {\r\n      setUser(session?.user ?? null);\r\n      setLoading(false);\r\n    });\r\n\r\n    return () => subscription.unsubscribe();\r\n  }, [supabase]);\r\n\r\n  if (!supabase) {\r\n    return {\r\n      user: null,\r\n      loading: false,\r\n      error: \"Supabase client not found (check env vars)\",\r\n    };\r\n  }\r\n\r\n  // Mimic original behavior: if no user, return error \"User not found\" so consumers know?\r\n  // Or just return user: null.\r\n  // The original code threw \"User not found\" which was caught and returned as error.\r\n  // I will just return user and loading status.\r\n  // If the consumer needs to handle \"not logged in\", they check !user.\r\n  // However, specifically for the previous behavior compatibility:\r\n  if (!loading && !user) {\r\n    return { user: null, loading: false, error: \"User not found\" };\r\n  }\r\n\r\n  return { user, loading, error: null };\r\n}\r\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/supabase/lib/client.ts",
      "content": "import { createBrowserClient } from \"@supabase/ssr\";\r\n\r\nexport function createClient() {\r\n  const { NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY } =\r\n    process.env;\r\n\r\n  if (!NEXT_PUBLIC_SUPABASE_URL || !NEXT_PUBLIC_SUPABASE_ANON_KEY) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    return createBrowserClient(\r\n      NEXT_PUBLIC_SUPABASE_URL,\r\n      NEXT_PUBLIC_SUPABASE_ANON_KEY,\r\n    );\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/supabase/lib/middleware.ts",
      "content": "import { type CookieOptions, createServerClient } from \"@supabase/ssr\";\r\nimport { type NextRequest, NextResponse } from \"next/server\";\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n  let supabaseResponse = NextResponse.next({\r\n    request,\r\n  });\r\n  const { NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY } =\r\n    process.env;\r\n\r\n  if (!NEXT_PUBLIC_SUPABASE_URL || !NEXT_PUBLIC_SUPABASE_ANON_KEY) {\r\n    throw new Error(\"Missing Supabase environment variables\");\r\n  }\r\n\r\n  const supabase = createServerClient(\r\n    NEXT_PUBLIC_SUPABASE_URL,\r\n    NEXT_PUBLIC_SUPABASE_ANON_KEY,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return request.cookies.getAll().map((cookie) => ({\r\n            name: cookie.name,\r\n            value: cookie.value,\r\n          }));\r\n        },\r\n        setAll(\r\n          cookiesToSet: {\r\n            name: string;\r\n            value: string;\r\n            options: CookieOptions;\r\n          }[],\r\n        ) {\r\n          cookiesToSet.forEach(({ name, value }) => {\r\n            request.cookies.set(name, value);\r\n          });\r\n          supabaseResponse = NextResponse.next({\r\n            request,\r\n          });\r\n          cookiesToSet.forEach(({ name, value, options }) => {\r\n            supabaseResponse.cookies.set(name, value, options);\r\n          });\r\n        },\r\n      },\r\n    },\r\n  );\r\n\r\n  // IMPORTANT: getClaims() validates the JWT and refreshes the session\r\n  // Do not use getSession() in server code as it doesn't revalidate the token\r\n  await supabase.auth.getClaims();\r\n\r\n  return supabaseResponse;\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/supabase/lib/server.ts",
      "content": "import { type CookieOptions, createServerClient } from \"@supabase/ssr\";\r\nimport { cookies } from \"next/headers\";\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies();\r\n  const { NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY } =\r\n    process.env;\r\n\r\n  if (!NEXT_PUBLIC_SUPABASE_URL || !NEXT_PUBLIC_SUPABASE_ANON_KEY) {\r\n    throw new Error(\"Missing Supabase environment variables\");\r\n  }\r\n\r\n  return createServerClient(\r\n    NEXT_PUBLIC_SUPABASE_URL,\r\n    NEXT_PUBLIC_SUPABASE_ANON_KEY,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll().map((cookie) => ({\r\n            name: cookie.name,\r\n            value: cookie.value,\r\n          }));\r\n        },\r\n        setAll(\r\n          cookiesToSet: {\r\n            name: string;\r\n            value: string;\r\n            options: CookieOptions;\r\n          }[],\r\n        ) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) => {\r\n              cookieStore.set(name, value, options);\r\n            });\r\n          } catch {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    },\r\n  );\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/supabase/pages/sign-in.tsx",
      "content": "import { SignInForm } from \"@/registry/new-york/supabase/components/sign-in-form\";\r\n\r\nexport default function Page() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-center px-4\">\r\n      <div className=\"w-full max-w-md\">\r\n        <h1 className=\"mb-4 text-xl font-semibold text-foreground\">Sign In</h1>\r\n        <SignInForm redirect=\"/\" />\r\n      </div>\r\n    </main>\r\n  );\r\n}\r\n",
      "type": "registry:page",
      "target": "~/app/auth/sign-in/page.tsx"
    },
    {
      "path": "registry/new-york/supabase/pages/sign-up.tsx",
      "content": "import { SignUpForm } from \"@/registry/new-york/supabase/components/sign-up-form\";\r\n\r\nexport default function Page() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-center px-4\">\r\n      <div className=\"w-full max-w-md\">\r\n        <h1 className=\"mb-4 text-xl font-semibold text-foreground\">Sign In</h1>\r\n        <SignUpForm />\r\n      </div>\r\n    </main>\r\n  );\r\n}\r\n",
      "type": "registry:page",
      "target": "~/app/auth/sign-up/page.tsx"
    },
    {
      "path": "registry/new-york/supabase/api/sign-in.ts",
      "content": "import { NextRequest, NextResponse } from \"next/server\";\r\nimport { signInSchema } from \"@/registry/new-york/supabase/components/sign-in-form\";\r\nimport { createClient } from \"@/registry/new-york/supabase/lib/server\";\r\n\r\nexport async function POST(request: NextRequest) {\r\n  const body = request.json();\r\n  const parsedBody = signInSchema.safeParse(body);\r\n  if (!parsedBody.success) {\r\n    return NextResponse.json(\r\n      { error: parsedBody.error.message },\r\n      { status: 400 },\r\n    );\r\n  }\r\n  try {\r\n    const supabase = await createClient();\r\n    if (!supabase) {\r\n      throw new Error(\"Supabase client not found\");\r\n    }\r\n    const { error, data } = await supabase.auth.signInWithPassword({\r\n      email: parsedBody.data.email,\r\n      password: parsedBody.data.password,\r\n    });\r\n    if (error) {\r\n      return NextResponse.json({ error: error.message }, { status: 400 });\r\n    }\r\n    return NextResponse.json({ data }, { status: 200 });\r\n  } catch {\r\n    return NextResponse.json(\r\n      { error: \"Something went wrong\" },\r\n      { status: 400 },\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:page",
      "target": "~/app/api/auth/sign-in/route.ts"
    },
    {
      "path": "registry/new-york/supabase/api/sign-up.ts",
      "content": "import { NextRequest, NextResponse } from \"next/server\";\r\n\r\nimport { signUpSchema } from \"@/registry/new-york/supabase/components/sign-up-form\";\r\nimport { createClient } from \"@/registry/new-york/supabase/lib/server\";\r\n\r\nexport async function POST(request: NextRequest) {\r\n  const body = await request.json();\r\n  const parsedBody = signUpSchema.safeParse(body);\r\n  if (!parsedBody.success) {\r\n    return NextResponse.json(\r\n      { error: parsedBody.error.message },\r\n      { status: 400 },\r\n    );\r\n  }\r\n  if (parsedBody.data.password !== parsedBody.data.confirmPassword) {\r\n    return NextResponse.json(\r\n      { error: \"Passwords do not match\" },\r\n      { status: 400 },\r\n    );\r\n  }\r\n  try {\r\n    const supabase = await createClient();\r\n    if (!supabase) {\r\n      throw new Error(\"Supabase client not found\");\r\n    }\r\n    const { error, data } = await supabase.auth.signUp({\r\n      email: parsedBody.data.email,\r\n      password: parsedBody.data.password,\r\n      options: {\r\n        data: {\r\n          firstName: parsedBody.data.firstName,\r\n          lastName: parsedBody.data.lastName,\r\n        },\r\n      },\r\n    });\r\n    if (error) {\r\n      return NextResponse.json({ error: error.message }, { status: 400 });\r\n    }\r\n    return NextResponse.json({ data }, { status: 200 });\r\n  } catch {\r\n    return NextResponse.json(\r\n      { error: \"Something went wrong\" },\r\n      { status: 400 },\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:page",
      "target": "~/app/api/auth/sign-up/route.ts"
    }
  ],
  "envVars": {
    "NEXT_PUBLIC_SUPABASE_URL": "",
    "NEXT_PUBLIC_SUPABASE_ANON_KEY": ""
  }
}