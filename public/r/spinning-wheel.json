{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "spinning-wheel",
  "type": "registry:component",
  "title": "Spinning Wheel",
  "description": "A lottery-like spinning wheel component",
  "registryDependencies": [
    "https://sid-cn.vercel.app/r/button.json"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/spinning-wheel/spinning-wheel.tsx",
      "content": "\"use client\";\r\n\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useState, useRef } from \"react\";\r\n\r\nexport type Reward =\r\n  | {\r\n      reward: string;\r\n      weight?: number;\r\n      bgColor: string;\r\n      textColor: string;\r\n    }\r\n  | {\r\n      reward: string;\r\n      weight?: number;\r\n    };\r\n\r\nexport function SpinningWheel({\r\n  rewardDetails,\r\n  disabled = false,\r\n  radius = 200,\r\n  setReward,\r\n}: {\r\n  rewardDetails: Reward[];\r\n  disabled?: boolean;\r\n  radius?: number;\r\n  setReward?: (reward: string | null) => void;\r\n}) {\r\n  // Seperate all the properties\r\n  const rewards = rewardDetails.map((reward) => reward.reward);\r\n  const bgColors = rewardDetails.every((reward) => \"bgColor\" in reward)\r\n    ? rewardDetails.map((reward) => reward.bgColor)\r\n    : [\"#FFF\", \"#000\"];\r\n\r\n  const textColors = rewardDetails.every((reward) => \"textColor\" in reward)\r\n    ? rewardDetails.map((reward) => reward.textColor)\r\n    : [\"#000\", \"#FFF\"];\r\n  let weights = rewardDetails.map((reward) => reward?.weight || 1);\r\n  if (!weights) {\r\n    weights = new Array(rewards.length).fill(1);\r\n  }\r\n\r\n  // State variables\r\n  const [isSpinning, setIsSpinning] = useState(false);\r\n  const [rotation, setRotation] = useState(0);\r\n  const [finalRotation, setFinalRotation] = useState(0);\r\n  const wheelRef = useRef(null);\r\n\r\n  // internal calculation variables\r\n  const totalWeights = weights.reduce((a, b) => a + b, 0);\r\n  const segmentAngle = 360 / rewards.length;\r\n  const calcSegmentAngle = 360 / totalWeights;\r\n  const calcRewards = rewards\r\n    .map((reward, index) => new Array(weights[index]).fill(reward))\r\n    .flat();\r\n\r\n  const spinWheel = () => {\r\n    if (isSpinning) return;\r\n\r\n    setIsSpinning(true);\r\n    if (setReward) setReward(null);\r\n\r\n    // Determine a random position to stop (between 2 and 5 full rotations + random segment)\r\n    const minRotations = 5;\r\n    const maxRotations = 7;\r\n    const randomRotations =\r\n      minRotations + Math.random() * (maxRotations - minRotations);\r\n    const randomRewardIndex = Math.floor(Math.random() * totalWeights);\r\n    const randomAngle =\r\n      segmentAngle * rewards.indexOf(calcRewards[randomRewardIndex]);\r\n\r\n    const totalRotation = randomRotations * 360 + randomAngle;\r\n\r\n    // Determine the final rotation\r\n    const newFinalRotation = rotation + totalRotation;\r\n    setFinalRotation(newFinalRotation);\r\n\r\n    // Determine the selected reward based on where the wheel stops\r\n    const normalizedRotation = newFinalRotation % 360;\r\n    const selectedIndex =\r\n      Math.floor((360 - normalizedRotation) / calcSegmentAngle) % totalWeights;\r\n\r\n    // Delay setting the reward to match the animation completion\r\n    setTimeout(() => {\r\n      if (setReward) setReward(calcRewards[selectedIndex]);\r\n      setRotation(newFinalRotation);\r\n      setIsSpinning(false);\r\n    }, 5000);\r\n  };\r\n\r\n  // Generate wheel segments\r\n  const renderWheel = () => {\r\n    return (\r\n      <svg\r\n        width=\"100%\"\r\n        height=\"100%\"\r\n        viewBox={`0 0 ${2 * radius} ${2 * radius}`}\r\n        className=\"rounded-full\"\r\n      >\r\n        {/* Background circle */}\r\n        <circle cx={`${radius}`} cy={`${radius}`} r={`${radius}`} fill=\"#FFF\" />\r\n\r\n        {/* Segments */}\r\n        {rewards.map((reward, index) => {\r\n          const startAngle = index * segmentAngle;\r\n          const endAngle = (index + 1) * segmentAngle;\r\n\r\n          // Convert angles to radians for SVG calculations\r\n          const startRad = ((startAngle - 90) * Math.PI) / 180;\r\n          const endRad = ((endAngle - 90) * Math.PI) / 180;\r\n\r\n          // Calculate points on the circle\r\n          const x1 = radius + radius * Math.cos(startRad);\r\n          const y1 = radius + radius * Math.sin(startRad);\r\n          const x2 = radius + radius * Math.cos(endRad);\r\n          const y2 = radius + radius * Math.sin(endRad);\r\n\r\n          // Create path for segment\r\n          const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\r\n          const path = `M ${radius} ${radius} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;\r\n\r\n          // Calculate text position\r\n          const textAngle = (startAngle + endAngle) / 2;\r\n          const textRad = ((textAngle - 90) * Math.PI) / 180;\r\n          const textX = radius + radius * 0.7 * Math.cos(textRad);\r\n          const textY = radius + radius * 0.7 * Math.sin(textRad);\r\n          const textRotation =\r\n            textAngle > 90 && textAngle < 270 ? textAngle + 180 : textAngle;\r\n\r\n          return (\r\n            <g key={index}>\r\n              <path\r\n                d={path}\r\n                fill={bgColors[index % bgColors.length]}\r\n                stroke={textColors[index % textColors.length]}\r\n                strokeWidth=\"2\"\r\n              />\r\n              <text\r\n                x={textX}\r\n                y={textY}\r\n                fontSize=\"16\"\r\n                fontWeight=\"bold\"\r\n                fill={textColors[index % textColors.length]}\r\n                textAnchor=\"middle\"\r\n                dominantBaseline=\"middle\"\r\n                transform={`rotate(${textRotation}, ${textX}, ${textY})`}\r\n              >\r\n                {reward}\r\n              </text>\r\n            </g>\r\n          );\r\n        })}\r\n\r\n        {/* Center circle */}\r\n        <circle cx={`${radius}`} cy={`${radius}`} r=\"30\" fill=\"#333\" />\r\n        <text\r\n          x={`${radius}`}\r\n          y={`${radius}`}\r\n          fontSize=\"14\"\r\n          fontWeight=\"bold\"\r\n          fill=\"white\"\r\n          textAnchor=\"middle\"\r\n          dominantBaseline=\"middle\"\r\n        >\r\n          SPIN\r\n        </text>\r\n      </svg>\r\n    );\r\n  };\r\n\r\n  if (weights !== null && weights.length !== rewards.length) {\r\n    throw new Error(\r\n      \"`weights` should either be null or an array with same length as the `rewards`.\"\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex flex-col items-center justify-center space-y-6 p-4\">\r\n      <div className=\"relative w-64 h-64\">\r\n        {/* Wheel */}\r\n        <div\r\n          ref={wheelRef}\r\n          className=\"w-full h-full rounded-full relative\"\r\n          style={{\r\n            transform: `rotate(${finalRotation}deg)`,\r\n            transition: isSpinning\r\n              ? \"transform 5s cubic-bezier(0.2, 0.8, 0.2, 1)\"\r\n              : \"none\",\r\n          }}\r\n        >\r\n          {renderWheel()}\r\n        </div>\r\n\r\n        {/* Pointer/Ticker */}\r\n        <div className=\"absolute top-0 left-1/2 w-6 h-8 -ml-3 z-10\">\r\n          <svg width=\"100%\" height=\"100%\" viewBox=\"0 0 24 32\">\r\n            <polygon points=\"12,32 0,0 24,0\" fill=\"#ffd700\" />\r\n          </svg>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Controls */}\r\n      <Button onClick={spinWheel} disabled={isSpinning || disabled}>\r\n        {isSpinning ? \"Spinning...\" : \"Spin the Wheel\"}\r\n      </Button>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:block"
    }
  ]
}