{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "markdown-editor",
  "type": "registry:block",
  "title": "Markdown Editor",
  "description": "A beautiful markdown editor component",
  "dependencies": [
    "lucide-react",
    "marked"
  ],
  "registryDependencies": [
    "https://sid-cn.vercel.app/r/button.json",
    "separator",
    "textarea"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/markdown-editor/markdown-editor.tsx",
      "content": "\"use client\";\r\n\r\nimport { Bold, Italic, List, ListOrdered, Link } from \"lucide-react\";\r\nimport { marked } from \"marked\";\r\nimport React from \"react\";\r\n\r\nimport { Button } from \"@/registry/new-york/components/button\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\n\r\nexport interface MarkdownEditorProps {\r\n  initialValue?: string;\r\n  onChange?: (value: string) => void;\r\n}\r\n\r\nexport function MarkdownEditor({\r\n  initialValue = \"\",\r\n  onChange,\r\n}: MarkdownEditorProps) {\r\n  const [markdown, setMarkdown] = React.useState(initialValue);\r\n  const [parsedHtml, setParsedHtml] = React.useState<string>(\"\");\r\n  const textareaRef = React.useRef<HTMLTextAreaElement>(null);\r\n\r\n  const handleMarkdownChange = React.useCallback(\r\n    (value: string) => {\r\n      setMarkdown(value);\r\n      onChange?.(value);\r\n    },\r\n    [onChange]\r\n  );\r\n\r\n  const parseMarkdown = React.useCallback(\r\n    async (text: string): Promise<string> => {\r\n      try {\r\n        const result = await marked(text, {\r\n          breaks: true,\r\n          gfm: true,\r\n        });\r\n        return result;\r\n      } catch (error) {\r\n        console.error(\"Error parsing markdown:\", error);\r\n        return text;\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  const insertMarkdown = React.useCallback(\r\n    (before: string, after = \"\", placeholder = \"\") => {\r\n      const textarea = textareaRef.current;\r\n      if (!textarea) return;\r\n\r\n      const start = textarea.selectionStart;\r\n      const end = textarea.selectionEnd;\r\n      const selectedText = textarea.value.substring(start, end);\r\n\r\n      // Check if the selected text is already wrapped with the markdown syntax\r\n      const beforeStart = start - before.length;\r\n      const afterEnd = end + after.length;\r\n      const textBefore = textarea.value.substring(beforeStart, start);\r\n      const textAfter = textarea.value.substring(end, afterEnd);\r\n\r\n      const isAlreadyFormatted = textBefore === before && textAfter === after;\r\n\r\n      if (isAlreadyFormatted && selectedText) {\r\n        // Remove the formatting\r\n        const newText =\r\n          textarea.value.substring(0, beforeStart) +\r\n          selectedText +\r\n          textarea.value.substring(afterEnd);\r\n\r\n        handleMarkdownChange(newText);\r\n\r\n        setTimeout(() => {\r\n          textarea.focus();\r\n          textarea.setSelectionRange(\r\n            beforeStart,\r\n            beforeStart + selectedText.length\r\n          );\r\n        }, 0);\r\n      } else if (selectedText) {\r\n        // Check if selected text itself contains the markdown syntax\r\n        const trimmedBefore = before.trim();\r\n        const trimmedAfter = after.trim();\r\n\r\n        if (\r\n          selectedText.startsWith(trimmedBefore) &&\r\n          selectedText.endsWith(trimmedAfter) &&\r\n          selectedText.length > trimmedBefore.length + trimmedAfter.length\r\n        ) {\r\n          // Remove formatting from selected text\r\n          const unformattedText = selectedText.substring(\r\n            trimmedBefore.length,\r\n            selectedText.length - trimmedAfter.length\r\n          );\r\n          const newText =\r\n            textarea.value.substring(0, start) +\r\n            unformattedText +\r\n            textarea.value.substring(end);\r\n\r\n          handleMarkdownChange(newText);\r\n\r\n          setTimeout(() => {\r\n            textarea.focus();\r\n            textarea.setSelectionRange(start, start + unformattedText.length);\r\n          }, 0);\r\n        } else {\r\n          // Add formatting to selected text\r\n          const newText =\r\n            textarea.value.substring(0, start) +\r\n            before +\r\n            selectedText +\r\n            after +\r\n            textarea.value.substring(end);\r\n\r\n          handleMarkdownChange(newText);\r\n\r\n          setTimeout(() => {\r\n            textarea.focus();\r\n            textarea.setSelectionRange(\r\n              start + before.length,\r\n              start + before.length + selectedText.length\r\n            );\r\n          }, 0);\r\n        }\r\n      } else {\r\n        // No text selected, insert placeholder\r\n        const textToInsert = placeholder;\r\n        const newText =\r\n          textarea.value.substring(0, start) +\r\n          before +\r\n          textToInsert +\r\n          after +\r\n          textarea.value.substring(end);\r\n\r\n        handleMarkdownChange(newText);\r\n\r\n        setTimeout(() => {\r\n          textarea.focus();\r\n          textarea.setSelectionRange(\r\n            start + before.length,\r\n            start + before.length + textToInsert.length\r\n          );\r\n        }, 0);\r\n      }\r\n    },\r\n    [handleMarkdownChange]\r\n  );\r\n\r\n  const insertAtLineStart = React.useCallback(\r\n    (prefix: string) => {\r\n      const textarea = textareaRef.current;\r\n      if (!textarea) return;\r\n\r\n      const start = textarea.selectionStart;\r\n      const value = textarea.value;\r\n\r\n      // Find the start of the current line\r\n      const lineStart = value.lastIndexOf(\"\\n\", start - 1) + 1;\r\n      const lineEnd = value.indexOf(\"\\n\", start);\r\n      const currentLine = value.substring(\r\n        lineStart,\r\n        lineEnd === -1 ? value.length : lineEnd\r\n      );\r\n\r\n      // Check if line already has the prefix\r\n      if (currentLine.startsWith(prefix)) {\r\n        // Remove the prefix\r\n        const newText =\r\n          value.substring(0, lineStart) +\r\n          currentLine.substring(prefix.length) +\r\n          value.substring(lineEnd === -1 ? value.length : lineEnd);\r\n        handleMarkdownChange(newText);\r\n        setTimeout(() => {\r\n          textarea.focus();\r\n          textarea.setSelectionRange(\r\n            start - prefix.length,\r\n            start - prefix.length\r\n          );\r\n        }, 0);\r\n      } else {\r\n        // Add the prefix\r\n        const newText =\r\n          value.substring(0, lineStart) +\r\n          prefix +\r\n          currentLine +\r\n          value.substring(lineEnd === -1 ? value.length : lineEnd);\r\n        handleMarkdownChange(newText);\r\n        setTimeout(() => {\r\n          textarea.focus();\r\n          textarea.setSelectionRange(\r\n            start + prefix.length,\r\n            start + prefix.length\r\n          );\r\n        }, 0);\r\n      }\r\n    },\r\n    [handleMarkdownChange]\r\n  );\r\n\r\n  const formatBold = () => insertMarkdown(\"**\", \"**\", \"bold text\");\r\n  const formatItalic = () => insertMarkdown(\"*\", \"*\", \"italic text\");\r\n  const formatLink = () => insertMarkdown(\"[\", \"](url)\", \"link text\");\r\n  const formatUnorderedList = () => insertAtLineStart(\"- \");\r\n  const formatOrderedList = () => insertAtLineStart(\"1. \");\r\n\r\n  const formatHeading = (level: number) => {\r\n    const textarea = textareaRef.current;\r\n    if (!textarea) return;\r\n\r\n    const start = textarea.selectionStart;\r\n    const value = textarea.value;\r\n\r\n    // Find the start of the current line\r\n    const lineStart = value.lastIndexOf(\"\\n\", start - 1) + 1;\r\n    const lineEnd = value.indexOf(\"\\n\", start);\r\n    const currentLine = value.substring(\r\n      lineStart,\r\n      lineEnd === -1 ? value.length : lineEnd\r\n    );\r\n\r\n    const headingPrefix = \"#\".repeat(level) + \" \";\r\n\r\n    // Check if line already has any heading\r\n    const existingHeadingMatch = currentLine.match(/^#+\\s/);\r\n\r\n    if (existingHeadingMatch) {\r\n      // Replace existing heading or remove if same level\r\n      if (existingHeadingMatch[0] === headingPrefix) {\r\n        // Remove heading\r\n        const newText =\r\n          value.substring(0, lineStart) +\r\n          currentLine.substring(existingHeadingMatch[0].length) +\r\n          value.substring(lineEnd === -1 ? value.length : lineEnd);\r\n        handleMarkdownChange(newText);\r\n        setTimeout(() => {\r\n          textarea.focus();\r\n          textarea.setSelectionRange(\r\n            start - existingHeadingMatch[0].length,\r\n            start - existingHeadingMatch[0].length\r\n          );\r\n        }, 0);\r\n      } else {\r\n        // Replace with new heading level\r\n        const newText =\r\n          value.substring(0, lineStart) +\r\n          headingPrefix +\r\n          currentLine.substring(existingHeadingMatch[0].length) +\r\n          value.substring(lineEnd === -1 ? value.length : lineEnd);\r\n        handleMarkdownChange(newText);\r\n        setTimeout(() => {\r\n          textarea.focus();\r\n          const diff = headingPrefix.length - existingHeadingMatch[0].length;\r\n          textarea.setSelectionRange(start + diff, start + diff);\r\n        }, 0);\r\n      }\r\n    } else {\r\n      // Add heading\r\n      const newText =\r\n        value.substring(0, lineStart) +\r\n        headingPrefix +\r\n        currentLine +\r\n        value.substring(lineEnd === -1 ? value.length : lineEnd);\r\n      handleMarkdownChange(newText);\r\n      setTimeout(() => {\r\n        textarea.focus();\r\n        textarea.setSelectionRange(\r\n          start + headingPrefix.length,\r\n          start + headingPrefix.length\r\n        );\r\n      }, 0);\r\n    }\r\n  };\r\n\r\n  const formatHorizontalRule = () => {\r\n    const textarea = textareaRef.current;\r\n    if (!textarea) return;\r\n\r\n    const start = textarea.selectionStart;\r\n    const value = textarea.value;\r\n\r\n    // Insert horizontal rule on a new line\r\n    const beforeCursor = value.substring(0, start);\r\n    const afterCursor = value.substring(start);\r\n\r\n    const needsNewlineBefore =\r\n      beforeCursor.length > 0 && !beforeCursor.endsWith(\"\\n\");\r\n    const needsNewlineAfter =\r\n      afterCursor.length > 0 && !afterCursor.startsWith(\"\\n\");\r\n\r\n    const hrText =\r\n      (needsNewlineBefore ? \"\\n\" : \"\") +\r\n      \"---\" +\r\n      (needsNewlineAfter ? \"\\n\" : \"\");\r\n    const newText = beforeCursor + hrText + afterCursor;\r\n\r\n    handleMarkdownChange(newText);\r\n    setTimeout(() => {\r\n      textarea.focus();\r\n      textarea.setSelectionRange(start + hrText.length, start + hrText.length);\r\n    }, 0);\r\n  };\r\n\r\n  const handleKeyDown = React.useCallback(\r\n    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\r\n      const isMac = navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0;\r\n      const ctrlKey = isMac ? e.metaKey : e.ctrlKey;\r\n\r\n      if (ctrlKey) {\r\n        switch (e.key.toLowerCase()) {\r\n          case \"1\":\r\n            e.preventDefault();\r\n            formatHeading(1);\r\n            break;\r\n          case \"2\":\r\n            e.preventDefault();\r\n            formatHeading(2);\r\n            break;\r\n          case \"3\":\r\n            e.preventDefault();\r\n            formatHeading(3);\r\n            break;\r\n          case \"b\":\r\n            e.preventDefault();\r\n            formatBold();\r\n            break;\r\n          case \"i\":\r\n            e.preventDefault();\r\n            formatItalic();\r\n            break;\r\n          case \"k\":\r\n            e.preventDefault();\r\n            formatLink();\r\n            break;\r\n          case \"shift\":\r\n            // Handle Ctrl+Shift combinations\r\n            if (e.shiftKey) {\r\n              switch (e.code) {\r\n                case \"Digit8\": // Ctrl+Shift+8 for unordered list\r\n                  e.preventDefault();\r\n                  formatUnorderedList();\r\n                  break;\r\n                case \"Digit7\": // Ctrl+Shift+7 for ordered list\r\n                  e.preventDefault();\r\n                  formatOrderedList();\r\n                  break;\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      }\r\n\r\n      // Handle Tab key for indentation\r\n      if (e.key === \"Tab\") {\r\n        e.preventDefault();\r\n        const textarea = e.currentTarget;\r\n        const start = textarea.selectionStart;\r\n        const end = textarea.selectionEnd;\r\n        const newText =\r\n          textarea.value.substring(0, start) +\r\n          \"  \" +\r\n          textarea.value.substring(end);\r\n        handleMarkdownChange(newText);\r\n        setTimeout(() => {\r\n          textarea.setSelectionRange(start + 2, start + 2);\r\n        }, 0);\r\n      }\r\n    },\r\n    [handleMarkdownChange]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const updatePreview = async () => {\r\n      if (markdown) {\r\n        const parsedHtml = await parseMarkdown(markdown);\r\n        setParsedHtml(parsedHtml);\r\n      } else {\r\n        setParsedHtml(\"\");\r\n      }\r\n    };\r\n    updatePreview();\r\n  }, [markdown, parseMarkdown]);\r\n\r\n  return (\r\n    <div className=\"w-full max-w-6xl mx-auto p-4\">\r\n      <div className=\"border rounded-lg overflow-hidden\">\r\n        {/* Toolbar */}\r\n        <div className=\"flex items-center gap-1 p-2 border-b bg-muted/50 overflow-x-auto\">\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={() => formatHeading(1)}\r\n            title=\"Heading 1 (Ctrl+1)\"\r\n          >\r\n            <span className=\"text-xs font-bold\">H1</span>\r\n          </Button>\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={() => formatHeading(2)}\r\n            title=\"Heading 2 (Ctrl+2)\"\r\n          >\r\n            <span className=\"text-xs font-bold\">H2</span>\r\n          </Button>\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={() => formatHeading(3)}\r\n            title=\"Heading 3 (Ctrl+3)\"\r\n          >\r\n            <span className=\"text-xs font-bold\">H3</span>\r\n          </Button>\r\n\r\n          <Separator orientation=\"vertical\" className=\"h-6 mx-1\" />\r\n\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={formatBold}\r\n            title=\"Toggle Bold (Ctrl+B)\"\r\n          >\r\n            <Bold className=\"h-4 w-4\" />\r\n          </Button>\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={formatItalic}\r\n            title=\"Toggle Italic (Ctrl+I)\"\r\n          >\r\n            <Italic className=\"h-4 w-4\" />\r\n          </Button>\r\n\r\n          <Separator orientation=\"vertical\" className=\"h-6 mx-1\" />\r\n\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={formatUnorderedList}\r\n            title=\"Unordered List (Ctrl+Shift+8)\"\r\n          >\r\n            <List className=\"h-4 w-4\" />\r\n          </Button>\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={formatOrderedList}\r\n            title=\"Ordered List (Ctrl+Shift+7)\"\r\n          >\r\n            <ListOrdered className=\"h-4 w-4\" />\r\n          </Button>\r\n\r\n          <Separator orientation=\"vertical\" className=\"h-6 mx-1\" />\r\n\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={formatLink}\r\n            title=\"Link (Ctrl+K)\"\r\n          >\r\n            <Link className=\"h-4 w-4\" />\r\n          </Button>\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={formatHorizontalRule}\r\n            title=\"Horizontal Rule\"\r\n          >\r\n            <span className=\"text-xs font-bold\">HR</span>\r\n          </Button>\r\n        </div>\r\n\r\n        {/* Editor and Preview */}\r\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 min-h-[500px]\">\r\n          {/* Editor */}\r\n          <Textarea\r\n            ref={textareaRef}\r\n            value={markdown}\r\n            onChange={(e) => handleMarkdownChange(e.target.value)}\r\n            onKeyDown={handleKeyDown}\r\n            placeholder=\"Start writing your markdown here...\"\r\n            className=\"w-full h-full min-h-[500px] border-0 resize-none font-mono text-sm rounded-none\"\r\n          />\r\n\r\n          {/* Preview */}\r\n          <div className=\"border-l bg-muted/20\">\r\n            <div className=\"p-4 h-full overflow-auto\">\r\n              <div className=\"prose prose-sm max-w-none prose-headings:mt-4 prose-headings:mb-2 prose-p:mb-2 prose-ul:my-2 prose-ol:my-2 prose-li:my-1\">\r\n                {markdown ? (\r\n                  <div\r\n                    dangerouslySetInnerHTML={{\r\n                      __html: parsedHtml,\r\n                    }}\r\n                  />\r\n                ) : (\r\n                  <p className=\"text-muted-foreground italic\">\r\n                    Preview will appear here as you type...\r\n                  </p>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Status Bar */}\r\n        <div className=\"flex items-center justify-between px-4 py-2 border-t bg-muted/50 text-sm text-muted-foreground\">\r\n          <div>\r\n            {markdown.length} characters, {markdown.split(\"\\n\").length} lines\r\n          </div>\r\n          <div className=\"hidden md:flex items-center gap-4\">\r\n            <div className=\"text-xs\">\r\n              <span className=\"font-medium\">Shortcuts:</span> Ctrl+B (Bold),\r\n              Ctrl+I (Italic), Ctrl+K (Link)\r\n            </div>\r\n          </div>\r\n          <div className=\"hidden sm:block md:hidden\">Markdown Editor</div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:block"
    }
  ]
}